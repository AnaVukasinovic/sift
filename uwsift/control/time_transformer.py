import logging
import time

from uwsift.common import DEFAULT_TIME_FORMAT

LOG = logging.getLogger(__name__)


class TimeTransformer:
    """
    Tick-to-Timestep Translator in concept.
        - get simulated time t_sim from driving layer/timeline
            at each tick: - check for curr. driving layer
                          - get t_sim from driving layer
        - sends t_sim to DisplayManager
    """
    def __init__(self, translation_policy):
        # Translation policy must always return a t_sim from its compute_t_sim method
        # driving layer is selected by most frequently occuring data
        # blueprint generated by config and/or UI?
        blueprint = {"Playback_Loop": "Wrapping",
                     "Advance_Time_By": ["DrivingLayer", ["ByMostFrequent", ["auto", "manual"]]]} # ByUserSelection
        # self._translation_policy = make_policy(blueprint)
        # Another example could be:
        # ..."Advance_Time_By": ["Aggregate", "Mean", "Some_Generating_Function"]...
        # --> computes t_sim by creating timeline containing mean timestamps where the
        #   mean is calculated by sampling all timelines according to some scheme

        self._translation_policy = translation_policy

        self.curr_tick_time: float = -1.0
        self.prev_tick_time: float = -1.0
        self._tick_delta: float = -1.0
        self._tick_accum: float = 0.
        self.t_sim = self._translation_policy.curr_t_sim()

    def create_formatted_time_stamp(self, fmt=DEFAULT_TIME_FORMAT):
        return self.t_sim.strftime(fmt)

    def tick(self, backwards=False):
        # tick times in milliseconds since Epoch
        self.curr_tick_time = time.time_ns()//1000000
        self.t_sim = self._translation_policy.compute_t_sim(self.curr_tick_time,
                                                            backwards=backwards)

